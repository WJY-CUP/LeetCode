## 1413. 逐步求和得到正数的最小值

### 题目链接

https://leetcode-cn.com/problems/minimum-value-to-get-positive-step-by-step-sum/



### 题目描述

给你一个整数数组 nums 。你可以选定任意的 正数 startValue 作为初始值。

你需要从左到右遍历 nums 数组，并将 startValue 依次累加上 nums 数组中的值。

请你在确保累加和始终大于等于 1 的前提下，选出一个最小的 正数 作为 startValue 。



**示例 1：**

~~~
输入：nums = [-3,2,-3,4,2]
输出：5
解释：如果你选择 startValue = 4，在第三次累加时，和小于 1 。
                累加求和
                startValue = 4 | startValue = 5 | nums
                  (4 -3 ) = 1  | (5 -3 ) = 2    |  -3
                  (1 +2 ) = 3  | (2 +2 ) = 4    |   2
                  (3 -3 ) = 0  | (4 -3 ) = 1    |  -3
                  (0 +4 ) = 4  | (1 +4 ) = 5    |   4
                  (4 +2 ) = 6  | (5 +2 ) = 7    |   2
~~~

**示例 2：**

~~~
输入：nums = [1,2]
输出：1
解释：最小的 startValue 需要是正数。
~~~

**提示：**

- `1 <= nums.length <= 100`
- `-100 <= nums[i] <= 100`



### 题解

**最小前缀和**

~~~C++
int minStartValue(vector<int>& nums) {
    vector<int> a;
    //依次求前缀和
    partial_sum(nums.begin(), nums.end(), back_inserter(a));
    //找出前缀和最小值
    int ans = *min_element(a.begin(), a.end());
    return ans <= 0 ? 1 - ans : 1;
}
~~~



### 拓展

#### 1. for_each

**for_each()是个 function template，其实质如下**

~~~C++
template<typename InputIterator, typename Function>
Function for_each(InputIterator beg, InputIterator end, Function f) {
  while(beg != end) 
    f(*beg++);
}
~~~

**用途：遍历容器**

~~~C++
//方式一
vector<int> vec;
for(int i=0;i<10;++i)
{
    vec.push_back(i);
}
for_each(vec.begin(), vec.end(), [](int i)->void{ cout << i <<" ";}); 


//方式二
void printValue(int a)
{
    cout << i <<" ";
}
int main(){
    vector<int> vec;
    for(int i=0;i<10;++i)
    {
        vec.push_back(i);
    }
    for_each(vec.begin(), vec.end(), printValue);
    
}


/*stdout
0 1 2 3 4 5 6 7 8 9 
*/
~~~



#### 2. 插入迭代器（back_inserter,inserter,front_inserter）

**除了普通迭代器，C++标准模板库还定义了几种特殊的迭代器，分别是插入迭代器、流迭代器、反向迭代器和移动迭代器，定义在<iterator>头文件中，下面主要介绍三种插入迭代器**



**首先，什么是插入迭代器？插入迭代器是指被绑定在一个容器上，可用来向容器插入元素的迭代器。**

- **back_inserter：创建一个使用push_back的迭代器**
- **inserter：此函数接受第二个参数，这个参数必须是一个指向给定容器的迭代器。元素将被插入到给定迭代器所表示的元素之前。**
- **front_inserter：创建一个使用push_front的迭代器（元素总是插入到容器第一个元素之前）**

**由于list容器类型是双向链表，支持push_front和push_back操作，因此选择list类型来试验这三个迭代器。**

~~~C++
list<int> lst = { 1, 2, 3, 4, 5, 6, 7, 8, 9 };
list<int> lst2 ={10}, lst3={10},lst4={10};

copy(lst.cbegin(), lst.cend(), back_inserter(lst2));
//lst2包含10,1,2,3,4,5,6,7,8,9

copy(lst.cbegin(), lst.cend(), inserter(lst3,lst3.begin()));
//lst3包含1,2,3,4,5,6,7,8,9,10

copy(lst.cbegin(), lst.cend(), front_inserter(lst4));
//lst4包含9,8,7,6,5,4,3,2,1,10
~~~



#### 3. push_back、push_front、insert



#### 3.1 push_back

**push_front有的支持有的不支持。insert和push_back一样，所有容器都支持。**

**和push_back()成对的pop_back()的作用的删除末尾的元素**



#### 3.2 push_front

~~~C++
//push_front用于在容器开头增加新的元素

list<int> lt;
lt.push_front(1);
lt.push_front(2);
lt.push_front(3);
~~~



#### 3.2 insert

**每个insert函数都接受一个迭代器作为其第一个参数。迭代器指出了在容器中什么位置放置新元素，他可以指向容器中任何位置，包括容器尾部之后的下一个位置。对于不支持push_front操作的容器，可以用insert来实现**

~~~C++
vector<string> svc;
svc.insert(svc.begin(),"front");
~~~

~~~C++
//在容器尾部添加5个4，相当于整体为1,2,3,4,4,4,4,4

vector<int> sec{1,2,3};
sec.insert(sec.end(),5,4);        
~~~

~~~C++
vector<string> v = {"MRA", "TZY", "WJY"};
vector<string> svc = {"WZ"};

//将v的最后两个元素插入到svc的第一个元素之前
svc.insert(svc.begin(),v.end()-2,v.end());    

//将这个初始化列表插入到svc的尾部
svc.insert(svc.end(),{"AB","CD ","EF ","GH"});    
~~~

