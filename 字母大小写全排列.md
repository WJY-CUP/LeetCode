## （一）题目描述

题目链接：https://leetcode-cn.com/problems/letter-case-permutation/



给定一个字符串`S`，通过将字符串`S`中的每个字母转变大小写，我们可以获得一个新的字符串。返回所有可能得到的字符串集合。

~~~
示例:
输入: S = "a1b2"
输出: ["a1b2", "a1B2", "A1b2", "A1B2"]

输入: S = "3z4"
输出: ["3z4", "3Z4"]

输入: S = "12345"
输出: ["12345"]
~~~

- `S` 的长度不超过`12`。
- `S` 仅由数字和字母组成。



## （二）题解

~~~C++
/*对于a1b2c3的求解过程
i = 0	result {a1b2c3,A1b2c3)
i = 1	S[1] = '1' 跳过
i = 2	result {a1b2c3,A1b2c3,a1B2c3,A1B2c3)
i = 3	S[3] = '2' 跳过
i = 4	result {a1b2c3,A1b2c3,a1B2c3,A1B2c3,a1b2C3,A1b2C3,a1B2C3,A1B2C3}
                
每次循环结果数量翻倍*/

vector<string> letterCasePermutation(string S) {
        vector<string> result{S};
    	//遍历S中的字符，非字母直接跳过
        for (int i = 0; i < S.size(); i++) {
            //如果是大写字母
            if (isupper(S[i])) {
                int size = result.size();
                //将result中的所有字符串第i位置的字符转化为小写
                for (int j = 0; j < size; j++) {
                    string temp = result[j];
                    temp[i] = tolower(temp[i]);
                    result.emplace_back(move(temp));
                }
            } 
            //如果是小写字母
            else if (islower(S[i])) {
                int size = result.size();
                //将result中的所有字符串第i位置的字符转化为大写
                for (int j = 0; j < size; j++) {
                    string temp = result[j];
                    temp[i] = toupper(temp[i]);
                    result.emplace_back(move(temp));
                }
            }
        }
        return result;
    }
~~~



## （三）拓展

### 1.push_back与emplace_back的区别

#### push_back:

push_back要求输入的参数是一个已经存在的对象。 当输入的参数，不是这样的对象时，会调用对应类的构造函数，构造一个临时的对象。
然后把这个对象执行拷贝构造函数或者移动构造函数插入到vector中。

#### emplace_back

emplace_back可以直接使用参数，在本地构建对象。这样一来，只需要调用构造函数，没有调用拷贝构造函数或者移动构造函数的过程。



### 2.引用

~~~
引用的特点：

①一个变量可取多个别名。

②引用必须初始化。

③引用只能在初始化的时候引用一次 ，不能更改为转而引用其他变量。
~~~

**①基础引用：**

~~~C++
int a = 1;
int& b = a;
cout<<"a:address->" <<&a<< endl;
cout<<"b:address->" <<&b<< endl;

a = 2;
b = 3;
int& c = b;// 引用一个引用变量，别名的别名
c = 4;// 此时b也变成4
~~~

**②const引用：**

~~~C++
int d1 = 4;
const int & d2 = d1;
d1 = 5;//d1改变，d2的值也会改变。
//d2 = 6;//不能给常量（不能被修改的量）赋值。

const int d3 = 1;
const int & d4 = d3;

//int&d5 = d3; //常量不能赋值给变量引用！！！
const int & d6 = 5;//常量具有常性，只有常引用可以引用常量，相当于d6为数字5的别名

double d7 = 1.1;
//int& d8 = d7;//d7是double类型，d8是int，d7赋值给 d8时要生成一个临时变量
//也就是说d8引用的是这个带有常性的临时变量，所以不能赋值。
const int& d9 = d7;
//此时改变d7，d9始终为1
~~~

**③引用作参数：**

~~~C++
1.【值传递】如果形参为非引用的传值方式，则生成局部临时变量接收实参的值
void Swap (int left, int right) //值传递的方式无法实现交换，因为传参时对于参数left和right拷贝一临时副本，交换的是副本值，因为其是临时变量函数退出，变量销 {                                //毁，并不会影响外部left和right的值。
     int temp = left;
     left = right ;
     right = temp ;
}
 
2.【引用传递】如果形参为引用类型，则形参是实参的别名。
void Swap (int& left, int& right)//使用引用的话，不做临时拷贝，&的使用说明此处只是原参数的另一个名字而已，所以修改时直接在原参数的基础上修改变量值。
{
     int temp = left;
     right = left ;
     left = temp ;
}
 
3.【指针传递】
void Swap (int* pLeft, int* pRight)//传入的是地址，因为地址是唯一的，所以指针通过地址的访问进而可修改其内容。
{
     int temp = *pLeft;
     *pLeft = *pRight;
     *pRight = temp;
}
~~~

**引用注意点**

~~~
1.对引用求地址，就是对目标变量求地址。即引用名是目标变量名的一个别名。引用在定义上是说引用不占据任何内存空间，但是编译器在一般将

其实现为const指针，即指向位置不可变的指针，所以引用实际上与一般指针同样占用内存。

2.不能建立引用的数组。因为数组是一个由若干个元素所组成的集合，所以无法建立一个由引用组成的集合，但是可以建立数组的引用。

3.引用常见的使用用途：作为函数的参数、函数的返回值。
~~~





#### 引用和指针的区别和联系：

**★不同点：**

~~~
1. 指针是一个实体，而引用仅是个别名；

2. 引用使用时无需解引用(*)，指针需要解引用；

3. 引用只能在定义时被初始化一次，之后不可变；指针可变；

4. 引用没有 const，指针有 const；const修饰的指针不可变；

5. 引用不能为空，指针可以为空；

6. “sizeof 引用”得到的是所指向的变量(对象)的大小，而“sizeof 指针”得到的是指针本身(所指向的变量或对象的地址)的大小；

7. 指针和引用的自增(++)运算意义不一样；

8.从内存分配上看：程序为指针变量分配内存区域，而引用不需要分配内存区域。

9.引用比指针更安全。指针比引用更为灵活，但是其风险也很大。使用指针时一定要检查指针是否为空(NULL)，且空间回收后指针最好置零，以免野指针的发生造成内存泄漏等问题。
~~~

**★相同点：**

~~~
两者都是地址的概念，指针指向一块儿内存，其内容为所指内存的地址；引用是某块儿内存的别名。
~~~



### 3.左值、右值

~~~
在C++11中所有的值必属于左值、右值两者之一，右值又可以细分为纯右值、将亡值。在C++11中可以取地址的、有名字的就是左值，反之，不能取地址的、没有名字的就是右值（将亡值或纯右值）。

举个例子，int a = b+c, a 就是左值，其有变量名为a，通过&a可以获取该变量的地址；表达式b+c、函数int func()的返回值是右值，在其被赋值给某一变量前，我们不能通过变量名找到它，＆(b+c)这样的操作则不会通过编译。
~~~



### 4.右值、将亡值

~~~
C++11对C++98中的右值进行了扩充。在C++11中右值又分为纯右值（prvalue，Pure Rvalue）和将亡值（xvalue，eXpiring Value）。

其中纯右值的概念等同于我们在C++98标准中右值的概念，指的是临时变量和不跟对象关联的字面量值；

将亡值则是C++11新增的跟右值引用相关的表达式，这样表达式通常是将要被移动的对象（移为他用），比如返回右值引用T&&的函数返回值、std::move的返回值，或者转换为T&&的类型转换函数的返回值。

将亡值可以理解为通过“盗取”其他变量内存空间的方式获取到的值。在确保其他变量不再被使用、或即将被销毁时，通过“盗取”的方式可以避免内存空间的释放和分配，能够延长变量值的生命期。
~~~



### 5.左值引用、右值引用

~~~
左值引用就是对一个左值进行引用的类型。右值引用就是对一个右值进行引用的类型，事实上，由于右值通常不具有名字，我们也只能通过引用的方式找到它的存在。

右值引用和左值引用都是属于引用类型。无论是声明一个左值引用还是右值引用，都必须立即进行初始化。而其原因可以理解为是引用类型本身自己并不拥有所绑定对象的内存，只是该对象的一个别名。左值引用是具名变量值的别名，而右值引用则是不具名（匿名）变量的别名。

左值引用通常也不能绑定到右值，但常量左值引用是个“万能”的引用类型。它可以接受非常量左值、常量左值、右值对其进行初始化。不过常量左值所引用的右值在它的“余生”中只能是只读的。相对地，非常量左值只能接受非常量左值对其进行初始化。
~~~

~~~C++
int &a = 2;       # 左值引用绑定到右值，编译失败

int b = 2;        # 非常量左值
const int &c = b; # 常量左值引用绑定到非常量左值，编译通过
const int d = 2;  # 常量左值
const int &e = c; # 常量左值引用绑定到常量左值，编译通过
const int &b =2;  # 常量左值引用绑定到右值，编程通过
~~~

~~~
右值值引用通常不能绑定到任何的左值，要想绑定一个左值到右值引用，通常需要std::move()将左值强制转换为右值，例如：
~~~

~~~C++
int a;
int &&r1 = c;             # 编译失败
int &&r2 = std::move(a);  # 编译通过
~~~



### 6.Move()函数

~~~
通过std::move，可以避免不必要的拷贝操作。

std::move是为性能而生。

std::move是将对象的状态或者所有权从一个对象转移到另一个对象，只是转移，没有内存的搬迁或者内存拷贝。

如string类在赋值或者拷贝构造函数中会声明char数组来存放数据，然后把原string中的 char 数组被析构函数释放，如果a是一个临时变量，则上面的拷贝，析构就是多余的，完全可以把临时变量a中的数据直接 “转移” 到新的变量下面即可。
~~~

~~~C++
string str = "Hello";
vector<string> v;
//调用常规的拷贝构造函数，新建字符数组，拷贝数据
v.push_back(str);
cout << "After copy, str is \"" << str << "\"\n";
//调用移动构造函数，掏空str，掏空后，最好不要使用str
v.push_back(std::move(str));
cout << "After move, str is \"" << str << "\"\n";
cout << "The contents of the vector are \"" << v[0] << "\", \"" << v[1] << "\"\n";
~~~

~~~
After copy, str is "Hello"
After move, str is ""
The contents of the vector are "Hello", "Hello"
~~~













